 ### 7. æ˜ å°„ç±»å‹ mapping

åœ¨æ˜ å°„ä¸­ï¼Œäººå€‘å¯ä»¥é€ééµï¼ˆ Key ï¼‰ä¾†æŸ¥è©¢å°æ‡‰çš„å€¼ï¼ˆ Value ï¼‰ï¼Œä¾‹å¦‚ï¼šé€éä¸€å€‹äººçš„ id ä¾†æŸ¥è©¢ä»–çš„éŒ¢åŒ…ä½å€ã€‚

è²æ˜æ˜ å°„çš„æ ¼å¼ç‚º mapping(_KeyType => _ValueType) ï¼Œå…¶ä¸­ _KeyType å’Œ _ValueType åˆ†åˆ¥æ˜¯ Key å’Œ Value çš„è®Šæ•¸é¡å‹ã€‚ä¾‹å­ï¼š

  ```solidity
  mapping(uint => address) public idToAddress; // idæ˜ å°„åˆ°åœ°å€
  mapping(address => address) public swapPair; // å¸å¯¹çš„æ˜ å°„ï¼Œåœ°å€åˆ°åœ°å€
  ```

  æ˜ å°„çš„è¦å‰‡ï¼š

  - è¦å‰‡1ï¼š

    æ˜ å°„çš„ _KeyType åªèƒ½é¸æ“‡Solidityå…§å»ºçš„å€¼é¡å‹ï¼Œä¾‹å¦‚ uint ï¼Œ address ç­‰ï¼Œä¸èƒ½ç”¨è‡ªè¨‚çš„çµæ§‹é«”ã€‚è€Œ _ValueType å¯ä»¥ä½¿ç”¨è‡ªè¨‚çš„é¡å‹ã€‚ä¸‹é¢é€™å€‹ä¾‹å­æœƒå ±éŒ¯ï¼Œå› ç‚º _KeyType ä½¿ç”¨äº†æˆ‘å€‘è‡ªè¨‚çš„çµæ§‹é«”ï¼š

    ```solidity
      struct Student{
          uint256 id;
          uint256 score; 
      }
      mapping(Student => uint) public testVar;

      ```

      ```
        mapping(uint => address) public idToAddress;
        mapping(address => address) public swapPair;

        function writeMap (uint _Key, address _Value) public{
              idToAddress[_Key] = _Value;
        }

        // åˆå§‹å€¼
          ğŸ•µï¸ 0x0000000000000000000000000000000000000000
      ```
- æ˜ å°„çš„åŸç†
  - åŸç†1: æ˜ å°„ä¸å‚¨å­˜ä»»ä½•é”®ï¼ˆKeyï¼‰çš„èµ„è®¯ï¼Œä¹Ÿæ²¡æœ‰lengthçš„èµ„è®¯ã€‚

  - åŸç†2: æ˜ å°„ä½¿ç”¨keccak256(abi.encodePacked(key, slot))å½“æˆoffsetå­˜å–valueï¼Œå…¶ä¸­slotæ˜¯æ˜ å°„å˜é‡å®šä¹‰æ‰€åœ¨çš„æ’æ§½ä½ç½®ã€‚

  - åŸç†3: å› ä¸ºEthereumä¼šå®šä¹‰æ‰€æœ‰æœªä½¿ç”¨çš„ç©ºé—´ä¸º0ï¼Œæ‰€ä»¥æœªèµ‹å€¼ï¼ˆValueï¼‰çš„é”®ï¼ˆKeyï¼‰åˆå§‹å€¼éƒ½æ˜¯å„ä¸ªtypeçš„é»˜è®¤å€¼ï¼Œå¦‚uintçš„é»˜è®¤å€¼æ˜¯0ã€‚

### 8. å˜é‡åˆå§‹å€¼

æ‰€æœ‰å€¼çš„åˆå§‹å€¼å¦‚ä¸‹ï¼š

```solidity
bool public _bool; // false
string public _string; // ""
int public _int; // 0
uint public _uint; // 0
address public _address; // 0x0000000000000000000000000000000000000000

enum ActionSet { Buy, Hold, Sell}
ActionSet public _enum; // ç¬¬1ä¸ªå†…å®¹Buyçš„ç´¢å¼•0

function fi() internal{} // internalç©ºç™½å‡½æ•°
function fe() external{} // externalç©ºç™½å‡½æ•°

// Reference Types
uint[8] public _staticArray; // æ‰€æœ‰æˆå‘˜è®¾ä¸ºå…¶é»˜è®¤å€¼çš„é™æ€æ•°ç»„[0,0,0,0,0,0,0,0]
uint[] public _dynamicArray; // `[]`
mapping(uint => address) public _mapping; // æ‰€æœ‰å…ƒç´ éƒ½ä¸ºå…¶é»˜è®¤å€¼çš„mapping
// æ‰€æœ‰æˆå‘˜è®¾ä¸ºå…¶é»˜è®¤å€¼çš„ç»“æ„ä½“ 0, 0
struct Student{
    uint256 id;
    uint256 score;
}
Student public student;

// deleteæ“ä½œç¬¦
bool public _bool2 = true;
function d() external {
    delete _bool2; // delete ä¼šè®©_bool2å˜ä¸ºé»˜è®¤å€¼ï¼Œfalse
}

bytes1 // 0x00

```

### 9. å¸¸æ•¸constantå’Œimmutable

`constant`ï¼ˆå¸¸æ•¸ï¼‰å’Œ `immutable`ï¼ˆä¸è®Šé‡ï¼‰ã€‚
ç‹€æ…‹è®Šæ•¸å®£å‘Šé€™å…©å€‹é—œéµå­—ä¹‹å¾Œï¼Œåœ¨åˆå§‹åŒ–å¾Œä¸èƒ½æ›´æ”¹æ•¸å€¼ã€‚

`é€™æ¨£åšçš„å¥½è™•æ˜¯æå‡åˆç´„çš„å®‰å…¨æ€§ä¸¦ç¯€çœgasã€‚`

`constant`
```solidity
// constant å˜é‡å¿…é¡»åœ¨å£°æ˜çš„æ—¶å€™åˆå§‹åŒ–ï¼Œä¹‹åä¸èƒ½æ”¹å˜
uint256 constant CONSTANT_NUM = 10;
string constant CONSTANT_STRING = "0xAA";
bytes constant CONSTANT_BYTES = "WTF";
address constant CONSTANT_ADDRESS = 0x0000000000000000000000000000000000000000;

```
`immutable`
```solidity
// immutable å˜é‡å¯ä»¥åœ¨constructoré‡Œåˆå§‹åŒ–ï¼Œä¹‹åä¸èƒ½æ”¹å˜
uint256 public immutable IMMUTABLE_NUM = 9999999999;
address public immutable IMMUTABLE_ADDRESS;
uint256 public immutable IMMUTABLE_BLOCK;
uint256 public immutable IMMUTABLE_TEST;

constructor() {
    IMMUTABLE_ADDRESS = address(this);
    IMMUTABLE_NUM = 1118;
    IMMUTABLE_TEST = test();
}

```

`åªæœ‰æ•¸å€¼è®Šæ•¸å¯ä»¥å®£å‘Š constant å’Œ immutableï¼›string å’Œ bytes å¯ä»¥å®£å‘Šç‚ºconstantï¼Œä½†ä¸èƒ½ç‚ºimmutableã€‚`

ä¸‹åˆ—å“ªä¸€ä¸ªå˜é‡ä¸é€‚åˆç”¨ constant æˆ– immutable æ¥ä¿®é¥°ï¼Ÿ

 ç­”æ¡ˆï¼šåˆç´„çš„ï¼¥ï¼´ï¼¨é¤˜é¡ çœ‹åˆ°é€™é¡Œæœ‰é»é²ç–‘å¾Œé¢æƒ³æƒ³çš„ç¢ºæ˜¯ å“ˆå“ˆ


### 10. æ§åˆ¶æµï¼Œç”¨Solidityå¯¦ç¾æ’å…¥æ’åº

æ§åˆ¶
Solidityçš„æ§åˆ¶æµç¨‹èˆ‡å…¶ä»–èªè¨€é¡ä¼¼ï¼Œä¸»è¦åŒ…å«ä»¥ä¸‹å¹¾ç¨®ï¼š

`if-else`
```solidity
function ifElseTest(uint256 _number) public pure returns(bool){
    if(_number == 0){
        return(true);
    }else{
        return(false);
    }
}
```

`for`
```solidity
function forLoopTest() public pure returns(uint256){
    uint sum = 0;
    for(uint i = 0; i < 10; i++){
        sum += i;
    }
    return(sum);
}
```

`while`
```
function whileTest() public pure returns(uint256){
    uint sum = 0;
    uint i = 0;
    while(i < 10){
        sum += i;
        i++;
    }
    return(sum);
}
```

`do-while`
```solidity
function doWhileTest() public pure returns(uint256){
    uint sum = 0;
    uint i = 0;
    do{
        sum += i;
        i++;
    }while(i < 10);
    return(sum);
}
```

`ä¸‰å…ƒè¿ç®—ç¬¦`

ä¸‰å…ƒé‹ç®—å­æ˜¯Solidityä¸­å”¯ä¸€ä¸€å€‹æ¥å—ä¸‰å€‹é‹ç®—å…ƒçš„é‹ç®—ç¬¦ï¼Œè¦å‰‡æ¡ä»¶? æ¡ä»¶ä¸ºçœŸçš„è¡¨è¾¾å¼:æ¡ä»¶ä¸ºå‡çš„è¡¨è¾¾å¼ã€‚æ­¤é‹ç®—å­ç¶“å¸¸ç”¨ä½œifèªå¥çš„æ·å¾‘ã€‚
```solidity
// ä¸‰å…ƒè¿ç®—ç¬¦ ternary/conditional operator
function ternaryTest(uint256 x, uint256 y) public pure returns(uint256){
    // return the max of x and y
    return x >= y ? x: y; 
}
```

å¦å¤–é‚„æœ‰ `continue`ï¼ˆç«‹å³é€²å…¥ä¸‹ä¸€å€‹å¾ªç’°ï¼‰å’Œ `break`ï¼ˆè·³å‡ºç›®å‰å¾ªç’°ï¼‰é—œéµå­—å¯ä»¥ä½¿ç”¨ã€‚

`90%ä»¥ä¸Šçš„äººç”¨Solidityå¯«æ’å…¥æ¼”ç®—æ³•éƒ½æœƒå‡ºéŒ¯ã€‚`

æ’åºï¼š
Solidityä¸­æœ€å¸¸ç”¨çš„è®Šæ•¸é¡å‹æ˜¯ uintï¼Œä¹Ÿå°±æ˜¯æ­£æ•´æ•¸ï¼Œå–åˆ°è² å€¼çš„è©±ï¼Œæœƒå ± underflow éŒ¯èª¤ã€‚è€Œåœ¨æ’å…¥æ¼”ç®—æ³•ä¸­ï¼Œè®Šæ•¸jæœ‰å¯èƒ½æœƒå–åˆ°-1ï¼Œé€ æˆå ±éŒ¯ã€‚

é€™è£¡ï¼Œæˆ‘å€‘éœ€è¦æŠŠjåŠ 1ï¼Œè®“å®ƒç„¡æ³•å–åˆ°è² å€¼ã€‚æ­£ç¢ºä»£ç¢¼ï¼š
```solidity
// æ’å…¥æ’åº æ­£ç¡®ç‰ˆ
function insertionSort(uint[] memory a) public pure returns(uint[] memory) {
    // note that uint can not take negative value
    for (uint i = 1;i < a.length;i++){
        uint temp = a[i];
        uint j=i;
        while( (j >= 1) && (temp < a[j-1])){
            a[j] = a[j-1];
            j--;
        }
        a[j] = temp;
    }
    return(a);
}
```

### 11. æ„é€ å‡½æ•°å’Œä¿®é¥°å™¨

`æ„é€ å‡½æ•°`

åˆç´„éƒ¨ç½²çš„æ™‚å€™ç¬¬ä¸€å€‹åšçš„äº‹æƒ…ï¼Œå¦‚ä¸‹åˆå§‹åŒ– owner;
```
address public owner;

constructor() public {
    owner = msg.sender;
}
```

`ä¿®é¥°å™¨ modifier`

å¦‚ä¸‹ï¼š
```
// å®šä¹‰modifier
modifier onlyOwner {
   require(msg.sender == owner); // æ£€æŸ¥è°ƒç”¨è€…æ˜¯å¦ä¸ºowneråœ°å€
   _; // å¦‚æœæ˜¯çš„è¯ï¼Œç»§ç»­è¿è¡Œå‡½æ•°ä¸»ä½“ï¼›å¦åˆ™æŠ¥é”™å¹¶revertäº¤æ˜“
}

é…åˆ
function changeOwner(address _newOwner) external onlyOwner{
   owner = _newOwner; // åªæœ‰owneråœ°å€è¿è¡Œè¿™ä¸ªå‡½æ•°ï¼Œå¹¶æ”¹å˜owner
}
```